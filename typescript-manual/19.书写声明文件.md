[toc]

## 结构

### 概述

一般来讲，你*组织*声明文件的方式取决于库是如何被使用的。
在JavaScript中一个库有很多使用方式，这就需要你书写声明文件去匹配它们。
这篇指南涵盖了如何识别常见库的模式，和怎样书写符合相应模式的声明文件。

针对每种主要的库的组织模式，在[模版](./Templates.md)一节都有对应的文件。
你可以利用它们帮助你快速上手。

### 识别库的类型

首先，我们先看一下TypeScript声明文件能够表示的库的类型。
这里会简单展示每种类型的库的使用方式，如何去书写，还有一些真实案例。

识别库的类型是书写声明文件的第一步。
我们将会给出一些提示，关于怎样通过库的*使用方法*及其*源码*来识别库的类型。
根据库的文档及组织结构不同，这两种方式可能一个会比另外的那个简单一些。
我们推荐你使用任意你喜欢的方式。

#### 全局库

*全局*库是指能在全局命名空间下访问的（例如：不需要使用任何形式的`import`）。
许多库都是简单的暴露出一个或多个全局变量。
比如，如果你使用过[jQuery](https://jquery.com/)，`$`变量可以被够简单的引用：

```ts
$(() => { console.log('hello!'); } );
```

你经常会在全局库的指南文档上看到如何在HTML里用脚本标签引用库：

```html
<script src="http://a.great.cdn.for/someLib.js"></script>
```

目前，大多数流行的全局访问型库实际上都以UMD库的形式进行书写（见后文）。
UMD库的文档很难与全局库文档两者之间难以区分。
在书写全局声明文件前，一定要确认一下库是否真的不是UMD。

##### 从代码上识别全局库

全局库的代码通常都十分简单。
一个全局的“Hello, world”库可能是这样的：

```js
function createGreeting(s) {
    return "Hello, " + s;
}
```

或这样：

```js
window.createGreeting = function(s) {
    return "Hello, " + s;
}
```

当你查看全局库的源代码时，你通常会看到：

* 顶级的`var`语句或`function`声明
* 一个或多个赋值语句到`window.someName`
* 假设DOM原始值像`document`或`window`是存在的

你*不会*看到：

* 检查是否使用或如何使用模块加载器，比如`require`或`define`
* CommonJS/Node.js风格的导入如`var fs = require("fs");`
* `define(...)`调用
* 文档里说明了如何去`require`或导入这个库

##### 全局库的例子

由于把一个全局库转变成UMD库是非常容易的，所以很少流行的库还再使用全局的风格。
然而，小型的且需要DOM（或*没有*依赖）的库可能还是全局类型的。

##### 全局库模版

模版文件[`global.d.ts`](./templates/global.d.ts.md)定义了`myLib`库作为例子。
一定要阅读["防止命名冲突"补充说明](#preventing-name-conflicts)。

#### 模块化库

一些库只能工作在模块加载器的环境下。
比如，像`express`只能在Node.js里工作所以必须使用CommonJS的`require`函数加载。

ECMAScript 2015（也就是ES2015，ECMAScript 6或ES6），CommonJS和RequireJS具有相似的*导入*一个*模块*的表示方法。
例如，对于JavaScript CommonJS （Node.js），有下面的代码

```ts
var fs = require("fs");
```

对于TypeScript或ES6，`import`关键字也具有相同的作用：

```ts
import fs = require("fs");
```

你通常会在模块化库的文档里看到如下说明：

```js
var someLib = require('someLib');
```

或

```ts
define(..., ['someLib'], function(someLib) {

});
```

与全局模块一样，你也可能会在UMD模块的文档里看到这些例子，因此要仔细查看源码和文档。

##### 从代码上识别模块化库

模块库至少会包含下列具有代表性的条目之一：

* 无条件的调用`require`或`define`
* 像`import * as a from 'b';` or `export c;`这样的声明
* 赋值给`exports`或`module.exports`

它们极少包含：

* 对`window`或`global`的赋值

##### 模块化库的例子

许多流行的Node.js库都是这种模块化的，例如[`express`](http://expressjs.com/)，[`gulp`](http://gulpjs.com/)和[`request`](https://github.com/request/request)。

#### *UMD*

*UMD*模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。
许多流行的库，比如[Moment.js](http://momentjs.com/)，就是这样的形式。
比如，在Node.js或RequireJS里，你可以这样写：

```ts
import moment = require("moment");
console.log(moment.format());
```

然而在纯净的浏览器环境里你也可以这样写：

```ts
console.log(moment.format());
```

##### 识别UMD库

[UMD模块](https://github.com/umdjs/umd)会检查是否存在模块加载器环境。
这是非常形容观察到的模块，它们会像下面这样：

```js
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["libName"], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("libName"));
    } else {
        root.returnExports = factory(root.libName);
    }
}(this, function (b) {
```

如果你在库的源码里看到了`typeof define`，`typeof window`，或`typeof module`这样的测试，尤其是在文件的顶端，那么它几乎就是一个UMD库。

UMD库的文档里经常会包含通过`require`“在Node.js里使用”例子，
  和“在浏览器里使用”的例子，展示如何使用`<script>`标签去加载脚本。

##### UMD库的例子

大多数流行的库现在都能够被当成UMD包。
比如[jQuery](https://jquery.com/),[Moment.js](http://momentjs.com/),[lodash](https://lodash.com/)和许多其它的。

##### 模版

针对模块有三种可用的模块，
  [`module.d.ts`](./templates/module.d.ts.md), [`module-class.d.ts`](./templates/module-class.d.ts.md) and [`module-function.d.ts`](./templates/module-function.d.ts.md).

使用[`module-function.d.ts`](./templates/module-function.d.ts.md)，如果模块能够作为函数*调用*。

```ts
var x = require("foo");
// Note: calling 'x' as a function
var y = x(42);
```

一定要阅读[补充说明： “ES6模块调用签名的影响”](#the-impact-of-es6-on-module-call-signatures)

使用[`module-class.d.ts`](./templates/module-class.d.ts.md)如果模块能够使用`new`来*构造*：

```ts
var x = require("bar");
// Note: using 'new' operator on the imported variable
var y = new x("hello");
```

相同的[补充说明](#the-impact-of-es6-on-module-plugins)作用于这些模块。

如果模块不能被调用或构造，使用[`module.d.ts`](./templates/module.d.ts.md)文件。

#### *模块插件*或*UMD插件*

一个*模块插件*可以改变一个模块的结构（UMD或模块）。
例如，在Moment.js里，`moment-range`添加了新的`range`方法到`monent`对象。

对于声明文件的目标，我们会写相同的代码不论被改变的模块是一个纯粹的模块还是UMD模块。

##### 模版

使用[`module-plugin.d.ts`](./templates/module-plugin.d.ts.md)模版。

#### *全局插件*

一个*全局插件*是全局代码，它们会改变全局对象的结构。
对于*全局修改的模块*，在运行时存在冲突的可能。

比如，一些库往`Array.prototype`或`String.prototype`里添加新的方法。

##### 识别全局插件

全局通常很容易地从它们的文档识别出来。

你会看到像下面这样的例子：

```ts
var x = "hello, world";
// Creates new methods on built-in types
console.log(x.startsWithHello());

var y = [1, 2, 3];
// Creates new methods on built-in types
console.log(y.reverseAndSort());
```

##### 模版

使用[`global-plugin.d.ts`](./templates/global-plugin.d.ts.md)模版。

#### *全局修改的模块*

当一个*全局修改的模块*被导入的时候，它们会改变全局作用域里的值。
比如，存在一些库它们添加新的成员到`String.prototype`当导入它们的时候。
这种模式很危险，因为可能造成运行时的冲突，
  但是我们仍然可以为它们书写声明文件。

##### 识别全局修改的模块

全局修改的模块通常可以很容易地从它们的文档识别出来。
通常来讲，它们与全局插件相似，但是需要`require`调用来激活它们的效果。

你可能会看到像下面这样的文档:

```ts
// 'require' call that doesn't use its return value
var unused = require("magic-string-time");
/* or */
require("magic-string-time");

var x = "hello, world";
// Creates new methods on built-in types
console.log(x.startsWithHello());

var y = [1, 2, 3];
// Creates new methods on built-in types
console.log(y.reverseAndSort());
```

##### 模版

使用[`global-modifying-module.d.ts`](./templates/global-modifying-module.d.ts.md)模版。

### <a name="consuming-dependencies"></a>使用依赖

可能会有以下几种依赖。

#### 依赖全局库

如果你的库依赖于某个全局库，使用`/// <reference types="..." />`指令：

```ts
/// <reference types="someLib" />

function getThing(): someLib.thing;
```

#### 依赖模块

如果你的库依赖于模块，使用`import`语句：

```ts
import * as moment from "moment";

function getThing(): moment;
```

#### 依赖UMD库

##### 从全局库

如果你的全局库依赖于某个UMD模块，使用`/// <reference types`指令：

```ts
/// <reference types="moment" />

function getThing(): moment;
```

##### 从一个模块或UMD库

如果你的模块或UMD库依赖于一个UMD库，使用`import`语句：

```ts
import * as someLib from 'someLib';
```

*不要*使用`/// <reference`指令去声明UMD库的依赖！

### 补充说明

#### <a name="preventing-name-conflicts"></a>防止命名冲突

注意，在书写全局声明文件时，允许在全局作用域里定义很多类型。
我们十分不建义这样做，当一个工程里有许多声明文件时，它会导致无法处理的命名冲突。

一个简单的规则是使用库定义的全局变量名来声明命名空间类型。
比如，库定义了一个全局的值`cats`，你可以这样写

```ts
declare namespace cats {
    interface KittySettings { }
}
```

*不要*

```ts
// at top-level
interface CatsKittySettings { }
```

这样也保证了库在转换成UMD的时候没有任何的破坏式改变，对于声明文件用户来说。

#### <a name="the-impact-of-es6-on-module-plugins"></a>ES6模块插件的影响

一些插件添加或修改已存在的顶层模块的导出部分。
当然这在CommonJS和其它加载器里是允许的，ES模块被当作是不可改变的因此这种模式就不可行了。
因为TypeScript是能不预知加载器类型的，所以没没在编译时保证，但是开发者如果要转到ES6模块加载器上应该注意这一点。

#### <a name="the-impact-of-es6-on-module-call-signatures"></a>ES6模块调用签名的影响

很多流行库，比如Express，暴露出自己作为可以调用的函数。
比如，典型的Express使用方法如下：

```ts
import exp = require("express");
var app = exp();
```

在ES6模块加载器里，顶层的对象（这里以`exp`导入）只能具有属性；
  顶层的模块对象*永远不能*被调用。
十分常见的解决方法是定义一个`default`导出到一个可调用的/可构造的对象；
  一会模块加载器助手工具能够自己探测到这种情况并且使用`default`导出来替换顶层对象。
  
## 规范

### 普通类型

#### `Number`，`String`，`Boolean`和`Object`

*不要*使用如下类型`Number`，`String`，`Boolean`或`Object`。
这些类型指的是非原始的装盒对象，它们几乎没在JavaScript代码里正确地使用过。

```ts
/* 错误 */
function reverse(s: String): String;
```

*应该*使用类型`number`，`string`，and `boolean`。

```ts
/* OK */
function reverse(s: string): string;
```

使用非原始的`object`类型来代替`Object` （[TypeScript 2.2新增](../../release-notes/TypeScript 2.2.md#object-type)）

#### 泛型

*不要*定义一个从来没使用过其类型参数的泛型类型。
了解详情[TypeScript FAQ page](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---)。

<!-- TODO: More -->

### 回调函数类型

#### 回调函数返回值类型

<!-- TODO: Reword; these examples make no sense in the context of a declaration file -->

*不要*为返回值被忽略的回调函数设置一个`any`类型的返回值类型：

```ts
/* 错误 */
function fn(x: () => any) {
    x();
}
```

*应该*给返回值被忽略的回调函数设置`void`类型的返回值类型：

```ts
/* OK */
function fn(x: () => void) {
    x();
}
```

*为什么*：使用`void`相对安全，因为它防止了你不小心使用`x`的返回值：

```ts
function fn(x: () => void) {
    var k = x(); // oops! meant to do something else
    k.doSomething(); // error, but would be OK if the return type had been 'any'
}
```

#### 回调函数里的可选参数

*不要*在回调函数里使用可选参数除非你真的要这么做：

```ts
/* 错误 */
interface Fetcher {
    getObject(done: (data: any, elapsedTime?: number) => void): void;
}
```

这里有一种特殊的意义：`done`回调函数可能以1个参数或2个参数调用。
代码大概的意思是说这个回调函数不在乎是否有`elapsedTime`参数，
  但是不需要把这个参数当成可选参数来达到此目的 --
  因为总是允许提供一个接收较少参数的回调函数。

*应该*写出回调函数的非可选参数：

```ts
/* OK */
interface Fetcher {
    getObject(done: (data: any, elapsedTime: number) => void): void;
}
```

#### 重载与回调函数

*不要*因为回调函数参数个数不同而写不同的重载：

```ts
/* 错误 */
declare function beforeAll(action: () => void, timeout?: number): void;
declare function beforeAll(action: (done: DoneFn) => void, timeout?: number): void;
```

*应该*只使用最大参数个数写一个重载：

```ts
/* OK */
declare function beforeAll(action: (done: DoneFn) => void, timeout?: number): void;
```

*为什么*：回调函数总是可以忽略某个参数的，因此没必要为参数少的情况写重载。
参数少的回调函数首先允许错误类型的函数被传入，因为它们匹配第一个重载。

### 函数重载

#### 顺序

*不要*把一般的重载放在精确的重载前面：

```ts
/* 错误 */
declare function fn(x: any): any;
declare function fn(x: HTMLElement): number;
declare function fn(x: HTMLDivElement): string;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: any, wat?
```

*应该*排序重载令精确的排在一般的之前：

```ts
/* OK */
declare function fn(x: HTMLDivElement): string;
declare function fn(x: HTMLElement): number;
declare function fn(x: any): any;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: string, :)
```

*为什么*：TypeScript会选择*第一个匹配到的重载*当解析函数调用的时候。
当前面的重载比后面的“普通”，那么后面的被隐藏了不会被调用。

#### 使用可选参数

*不要*为仅在末尾参数不同时写不同的重载：

```ts
/* 错误 */
interface Example {
    diff(one: string): number;
    diff(one: string, two: string): number;
    diff(one: string, two: string, three: boolean): number;
}
```

*应该*尽可能使用可选参数：

```ts
/* OK */
interface Example {
    diff(one: string, two?: string, three?: boolean): number;
}
```

注意这在所有重载都有相同类型的返回值时会不好用。

*为什么*：有以下两个重要原因。

TypeScript解析签名兼容性时会查看是否某个目标签名能够使用源的参数调用，
  *且允许外来参数*。
下面的代码暴露出一个bug，当签名被正确的使用可选参数书写时：

```ts
function fn(x: (a: string, b: number, c: number) => void) { }
var x: Example;
// When written with overloads, OK -- used first overload
// When written with optionals, correctly an error
fn(x.diff);
```

第二个原因是当使用了TypeScript“严格检查null”特性时。
因为没有指定的参数在JavaScript里表示为`undefined`，通常显示地为可选参数传入一个`undefined`。
这段代码在严格null模式下可以工作：

```ts
var x: Example;
// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'
// When written with optionals, correctly OK
x.diff("something", true ? undefined : "hour");
```

#### 使用联合类型

*不要*为仅在某个位置上的参数类型不同的情况下定义重载：

```ts
/* WRONG */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number): Moment;
    utcOffset(b: string): Moment;
}
```

*应该*尽可能地使用联合类型：

```ts
/* OK */
interface Moment {
    utcOffset(): number;
    utcOffset(b: number|string): Moment;
}
```

注意我们没有让`b`成为可选的，因为签名的返回值类型不同。

*为什么*：This is important for people who are "passing through" a value to your function:

```ts
function fn(x: string): void;
function fn(x: number): void;
function fn(x: number|string) {
    // When written with separate overloads, incorrectly an error
    // When written with union types, correctly OK
    return moment().utcOffset(x);
}
```

## 举例

### 简介

这篇指南的目的是教你如何书写高质量的TypeScript声明文件。
我们在这里会展示一些API的文档，还有它们的使用示例，
  并且阐述了如何为它们书写声明文件。

这些例子是按复杂度递增的顺序组织的。

* [全局变量](#global-variables)
* [全局函数](#global-functions)
* [带属性的对象](#objects-with-properties)
* [函数重载](#overloaded-functions)
* [可重用类型（接口）](#reusable-types-interfaces)
* [可重用类型（类型别名）](#reusable-types-type-aliases)
* [组织类型](#organizing-types)
* [类](#classes)

### 例子

#### <a name="global-variables"></a>全局变量

*文档*

> 全局变量`foo`包含了存在组件总数。

*代码*

```ts
console.log("Half the number of widgets is " + (foo / 2));
```

*声明*

使用`declare var`声明变量。
如果变量是只读的，那么可以使用`declare const`。
你还可以使用`declare let`如果变量拥有块级作用域。

```ts
/** 组件总数 */
declare var foo: number;
```

#### <a name="global-functions"></a>全局函数

*文档*

> 用一个字符串参数调用`greet`函数向用户显示一条欢迎信息。

*代码*

```ts
greet("hello, world");
```

*声明*

使用`declare function`声明函数。

```ts
declare function greet(greeting: string): void;
```

#### <a name="objects-with-properties"></a>带属性的对象

*文档*

> 全局变量`myLib`包含一个`makeGreeting`函数，
> 还有一个属性`numberOfGreetings`指示目前为止欢迎数量。

*代码*

```ts
let result = myLib.makeGreeting("hello, world");
console.log("The computed greeting is:" + result);

let count = myLib.numberOfGreetings;
```

*声明*

使用`declare namespace`描述用点表示法访问的类型或值。

```ts
declare namespace myLib {
    function makeGreeting(s: string): string;
    let numberOfGreetings: number;
}
```

#### <a name="overloaded-functions"></a>函数重载

*文档*

> `getWidget`函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。

*代码*

```ts
let x: Widget = getWidget(43);

let arr: Widget[] = getWidget("all of them");
```

*声明*

```ts
declare function getWidget(n: number): Widget;
declare function getWidget(s: string): Widget[];
```

#### <a name="reusable-types-interfaces"></a>可重用类型（接口）

*文档*

> 当指定一个欢迎词时，你必须传入一个`GreetingSettings`对象。
> 这个对象具有以下几个属性：
>
> 1- greeting：必需的字符串
>
> 2- duration: 可靠的时长（毫秒表示）
>
> 3- color: 可选字符串，比如‘#ff00ff’

*代码*

```ts
greet({
  greeting: "hello world",
  duration: 4000
});
```

*声明*

使用`interface`定义一个带有属性的类型。

```ts
interface GreetingSettings {
  greeting: string;
  duration?: number;
  color?: string;
}

declare function greet(setting: GreetingSettings): void;
```

#### <a name="reusable-types-type-aliases"></a>可重用类型（类型别名）

*文档*

> 在任何需要欢迎词的地方，你可以提供一个`string`，一个返回`string`的函数或一个`Greeter`实例。

*代码*

```ts
function getGreeting() {
    return "howdy";
}
class MyGreeter extends Greeter { }

greet("hello");
greet(getGreeting);
greet(new MyGreeter());
```

*声明*

你可以使用类型别名来定义类型的短名：

```ts
type GreetingLike = string | (() => string) | MyGreeter;

declare function greet(g: GreetingLike): void;
```

#### <a name="organizing-types"></a>组织类型

*文档*

> `greeter`对象能够记录到文件或显示一个警告。
> 你可以为`.log(...)`提供LogOptions和为`.alert(...)`提供选项。

*代码*

```ts
const g = new Greeter("Hello");
g.log({ verbose: true });
g.alert({ modal: false, title: "Current Greeting" });
```

*声明*

使用命名空间组织类型。

```ts
declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
```

你也可以在一个声明中创建嵌套的命名空间：

```ts
declare namespace GreetingLib.Options {
    // Refer to via GreetingLib.Options.Log
    interface Log {
        verbose?: boolean;
    }
    interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
```

#### <a name="classes"></a>类

*文档*

> 你可以通过实例化`Greeter`对象来创建欢迎词，或者继承`Greeter`对象来自定义欢迎词。

*代码*

```ts
const myGreeter = new Greeter("hello, world");
myGreeter.greeting = "howdy";
myGreeter.showGreeting();

class SpecialGreeter extends Greeter {
    constructor() {
        super("Very special greetings");
    }
}
```

*声明*

使用`declare class`描述一个类或像类一样的对象。
类可以有属性和方法，就和构造函数一样。

```ts
declare class Greeter {
    constructor(greeting: string);

    greeting: string;
    showGreeting(): void;
}
```

<!-- Template

##

*Documentation*
>

*Code*

```ts

```

*Declaration*

```ts

```

-->

## 深入

### 声明文件原理：深入探究

组织模块以提供你想要的API形式保持一致是比较难的。
比如，你可能想要这样一个模块，可以用或不用`new`来创建不同的类型，
  在不同层级上暴露出不同的命名类型，
  且模块对象上还带有一些属性。

阅读这篇指定后，你就会了解如果书写复杂的暴露出友好API的声明文件。
这篇指定针对于模块（UMD）库，因为它们的选择具有更高的可变性。

#### 核心概念

如果你理解了一些关于TypeScript是如何工作的核心概念，
  那么你就能够为任何结构书写声明文件。

##### 类型

如果你正在阅读这篇指南，你可能已经大概了解TypeScript里的类型指是什么。
明确一下，*类型*通过以下方式引入：

* 类型别名声明（`type sn = number | string;`）
* 接口声明（`interface I { x: number[]; }`）
* 类声明（`class C { }`）
* 枚举声明（`enum E { A, B, C }`）
* 指向某个类型的`import`声明

以上每种声明形式都会创建一个新的类型名称。

##### 值

与类型相比，你可能已经理解了什么是值。
值是运行时名字，可以在表达式里引用。
比如`let x = 5;`创建一个名为`x`的值。

同样，以下方式能够创建值：

* `let`，`const`，和`var`声明
* 包含值的`namespace`或`module`声明
* `enum`声明
* `class`声明
* 指向值的`import`声明
* `function`声明

##### 命名空间

类型可以存在于*命名空间*里。
比如，有这样的声明`let x: A.B.C`，
  我们就认为`C`类型来自`A.B`命名空间。

这个区别虽细微但很重要 -- 这里，`A.B`不是必需的类型或值。

#### 简单的组合：一个名字，多种意义

一个给定的名字`A`，我们可以找出三种不同的意义：一个类型，一个值或一个命名空间。
要如何去解析这个名字要看它所在的上下文是怎样的。
比如，在声明`let m: A.A = A;`，
  `A`首先被当做命名空间，然后做为类型名，最后是值。
这些意义最终可能会指向完全不同的声明！

这看上去另人迷惑，但是只要我们不过度的重载这还是很方便的。
下面让我们来看看一些有用的组合行为。

##### 内置组合

眼尖的读者可能会注意到，比如，`class`同时出现在*类型*和*值*列表里。
`class C { }`声明创建了两个东西：
  *类型*`C`指向类的实例结构，
  *值*`C`指向类构造函数。
枚举声明拥有相似的行为。

##### 用户组合

假设我们写了模块文件`foo.d.ts`:

```ts
export var SomeVar: { a: SomeType };
export interface SomeType {
  count: number;
}
```

这样使用它：

```ts
import * as foo from './foo';
let x: foo.SomeType = foo.SomeVar.a;
console.log(x.count);
```

这可以很好地工作，但是我们知道`SomeType`和`SomeVar`很相关
  因此我们想让他们有相同的名字。
我们可以使用组合通过相同的名字`Bar`表示这两种不同的对象（值和对象）：

```ts
export var Bar: { a: Bar };
export interface Bar {
  count: number;
}
```

这提供了解构使用的机会：

```ts
import { Bar } from './foo';
let x: Bar = Bar.a;
console.log(x.count);
```

再次地，这里我们使用`Bar`做为类型和值。
注意我们没有声明`Bar`值为`Bar`类型 -- 它们是独立的。

#### 高级组合

有一些声明能够通过多个声明组合。
比如，`class C { }`和`interface C { }`可以同时存在并且都可以做为`C`类型的属性。

只要不产生冲突就是合法的。
一个普通的规则是值总是会和同名的其它值产生冲突除非它们在不同命名空间里，
  类型冲突则发生在使用类型别名声明的情况下（`type s = string`），
  命名空间永远不会发生冲突。

让我们看看如何使用。

##### 利用`interface`添加

我们可以使用一个`interface`往别一个`interface`声明里添加额外成员：

```ts
interface Foo {
  x: number;
}
// ... elsewhere ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

这同样作用于类：

```ts
class Foo {
  x: number;
}
// ... elsewhere ...
interface Foo {
  y: number;
}
let a: Foo = ...;
console.log(a.x + a.y); // OK
```

注意我们不能使用接口往类型别名里添加成员（`type s = string;`）

##### 使用`namespace`添加

`namespace`声明可以用来添加新类型，值和命名空间，只要不出现冲突。

比如，我们可能添加静态成员到一个类：

```ts
class C {
}
// ... elsewhere ...
namespace C {
  export let x: number;
}
let y = C.x; // OK
```

注意在这个例子里，我们添加一个值到`C`的*静态*部分（它的构造函数）。
这里因为我们添加了一个*值*，且其它值的容器是另一个值
  （类型包含于命名空间，命名空间包含于另外的命名空间）。

我们还可以给类添加一个命名空间类型：

```ts
class C {
}
// ... elsewhere ...
namespace C {
  export interface D { }
}
let y: C.D; // OK
```

在这个例子里，直到我们写了`namespace`声明才有了命名空间`C`。
做为命名空间的`C`不会与类创建的值`C`或类型`C`相互冲突。

最后，我们可以进行不同的合并通过`namespace`声明。
Finally, we could perform many different merges using `namespace` declarations.
This isn't a particularly realistic example, but shows all sorts of interesting behavior:

```ts
namespace X {
  export interface Y { }
  export class Z { }
}

// ... elsewhere ...
namespace X {
  export var Y: number;
  export namespace Z {
    export class C { }
  }
}
type X = string;
```

在这个例子里，第一个代码块创建了以下名字与含义：

* 一个值`X`（因为`namespace`声明包含一个值，`Z`）
* 一个命名空间`X`（因为`namespace`声明包含一个类型，`Y`）
* 在命名空间`X`里的类型`Y`
* 在命名空间`X`里的类型`Z`（类的实例结构）
* 值`X`的一个属性值`Z`（类的构造函数）

第二个代码块创建了以下名字与含义：

* 值`Y`（`number`类型），它是值`X`的一个属性
* 一个命名空间`Z`
* 值`Z`，它是值`X`的一个属性
* 在`X.Z`命名空间下的类型`C`
* 值`X.Z`的一个属性值`C`
* 类型`X`

#### 使用`export =`或`import`

一个重要的原则是`export`和`import`声明会导出或导入目标的*所有含义*。

<!-- TODO: Write more on that. -->

## 发布

现在我们已经按照指南里的步骤写好一个声明文件，是时候把它发布到npm了。
有两种主要方式用来发布声明文件到npm：

1. 与你的npm包捆绑在一起，或
2. 发布到npm上的[@types organization](https://www.npmjs.com/~types)。

如果你能控制要使用你发布的声明文件的那个npm包的话，推荐第一种方式。
这样的话，你的声明文件与JavaScript总是在一起传递。

### 包含声明文件到你的npm包

如果你的包有一个主`.js`文件，你还是需要在`package.json`里指定主声明文件。
设置`types`属性指向捆绑在一起的声明文件。
比如：

```json
{
    "name": "awesome",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/main.js",
    "types": "./lib/main.d.ts"
}
```

注意`"typings"`与`"types"`具有相同的意义，也可以使用它。

同样要注意的是如果主声明文件名是`index.d.ts`并且位置在包的根目录里（与`index.js`并列），你就不需要使用`"types"`属性指定了。

#### 依赖

所有的依赖是由npm管理的。
确保所依赖的声明包都在`package.json`的`"dependencies"`里指明了
比如，假设我们写了一个包它依赖于Browserify和TypeScript。

```json
{
    "name": "browserify-typescript-extension",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/main.js",
    "types": "./lib/main.d.ts",
    "dependencies": {
        "browserify": "latest",
        "@types/browserify": "latest",
        "typescript": "next"
    }
}
```

这里，我们的包依赖于`browserify`和`typescript`包。
`browserify`没有把它的声明文件捆绑在它的npm包里，所以我们需要依赖于`@types/browserify`得到它的声明文件。
`typescript`相反，它把声明文件放在了npm包里，因此我们不需要依赖额外的包。

我们的包要从这两个包里暴露出声明文件，因此`browserify-typescript-extension`的用户也需要这些依赖。
正因此，我们使用`"dependencies"`而不是`"devDependencies"`，否则用户将需要手动安装那些包。
如果我们只是在写一个命令行应用，并且我们的包不会被当做一个库使用的话，那么我就可以使用`devDependencies`。

#### 危险信号

##### `/// <reference path="..." />`

*不要*在声明文件里使用`/// <reference path="..." />`。

```ts
/// <reference path="../typescript/lib/typescriptServices.d.ts" />
....
```

*应该*使用`/// <reference types="..." />`代替

```ts
/// <reference types="typescript" />
....
```

务必阅读[使用依赖](./Library Structures.md#consuming-dependencies)一节了解详情。

##### 打包所依赖的声明

如果你的类型声明依赖于另一个包：

* *不要*把依赖的包放进你的包里，保持它们在各自的文件里。
* *不要*将声明拷贝到你的包里。
* *应该*依赖于npm类型声明包，如果依赖包没包含它自己的声明的话。

#### 公布你的声明文件

在发布声明文件包之后，确保在[DefinitelyTyped外部包列表](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types-2.0/notNeededPackages.json)里面添加一条引用。
这可以让查找工具知道你的包提供了自己的声明文件。

<!-- TODO: more about this. -->

### 发布到[@types](https://www.npmjs.com/~types)

[@types](https://www.npmjs.com/~types)下面的包是从[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)里自动发布的，通过[types-publisher工具](https://github.com/Microsoft/types-publisher)。
如果想让你的包发布为@types包，提交一个pull request到[https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)。
在这里查看详细信息[contribution guidelines page](http://definitelytyped.org/guides/contributing.html)。


## 使用

在TypeScript 2.0，获取、使用和查找声明文件变得十分容易。
这篇文章将详细说明怎么做这三件事。

### 下载

在TypeScript 2.0以上的版本，获取类型声明文件只需要使用npm。

比如，获取lodash库的声明文件，只需使用下面的命令：

```cmd
npm install --save @types/lodash
```

如果一个npm包像[Publishing](./Publishing.md)里所讲的一样已经包含了它的声明文件，那就不必再去下载相应的`@types`包了。

### 使用

下载完后，就可以直接在TypeScript里使用lodash了。
不论是在模块里还是全局代码里使用。

比如，你已经`npm install`安装了类型声明，你可以使用导入：

```ts
import * as _ from "lodash";
_.padStart("Hello TypeScript!", 20, " ");
```

或者如果你没有使用模块，那么你只需使用全局的变量`_`。

```ts
_.padStart("Hello TypeScript!", 20, " ");
```

### 查找

大多数情况下，类型声明包的名字总是与它们在`npm`上的包的名字相同，但是有`@types/`前缀，
  但如果你需要的话，你可以在[https://aka.ms/types](https://aka.ms/types)这里查找你喜欢的库。

> 注意：如果你要找的声明文件不存在，你可以贡献一份，这样就方便了下一位要使用它的人。
> 查看DefinitelyTyped[贡献指南页](http://definitelytyped.org/guides/contributing.html)了解详情。